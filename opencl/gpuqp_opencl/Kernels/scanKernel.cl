#define BITS        (5)#define MASK        ((1<<BITS)-1)//scan_warp: d_source is always been inclusively scanned, the return number is the right output//return: corresponding data of each thread indexint scan_warp(local int *d_source, const uint length, int isExclusive){    int localId = get_local_id(0);    const unsigned int lane = localId & MASK;        //warp size is 32    if (localId >= length)  return 0;       if (lane >= 1)      d_source[localId] += d_source[localId-1];    if (lane >= 2)      d_source[localId] += d_source[localId-2];    if (lane >= 4)      d_source[localId] += d_source[localId-4];    if (lane >= 8)      d_source[localId] += d_source[localId-8];    if (lane >= 16)     d_source[localId] += d_source[localId-16];    if (isExclusive == 0)   return d_source[localId];    else                    return (lane > 0)? d_source[localId-1] : 0;}//each block can process up to 1024*8=8192 elements if 1024 threads are used//return: the sum of this block of data(only true when it is a inclusive scan)kernel void scan_block(    global int *d_source,     const int length,     int isExclusive,    int isWriteSum,     global int *blockSum,    int warpSize,    int ele_per_thread,    local int* temp,    local int* warpSum,    local int* sumWarpSum    ){    int localId = get_local_id(0);    int globalId = get_global_id(0);    int blockSize = get_local_size(0);    int blockId = get_group_id(0);    const unsigned int lane = localId & MASK;    const unsigned int warpId = localId >> BITS;    // // extern __shared__ int share[];    // // __shared__ T temp[MAX_BLOCKSIZE*ELEMENT_PER_THREAD];                  //global data used in this block    // // __shared__ T warpSum[MAX_BLOCKSIZE];          // // __shared__ T sumWarpSum[WARPSIZE];    //global mem to shared mem, coalesced access    int startIdx = blockId * blockSize * ele_per_thread;    for(int i = localId; i < ele_per_thread * blockSize ; i += blockSize) {        if (startIdx + i >= length) break;        temp[i] = d_source[startIdx + i];    }    barrier(CLK_LOCAL_MEM_FENCE);    //endPlace: ending index of the part this block process    int endPlace = (blockId+1)*blockSize*ele_per_thread >= length?  length : (blockId+1)*blockSize*ele_per_thread;    int endEle = 0;    if ( isWriteSum==1 && (localId == 0) && isExclusive)   endEle = d_source[endPlace-1];    barrier(CLK_LOCAL_MEM_FENCE);    //doing the local scan    for(int i = localId * ele_per_thread + 1; i < (localId + 1) * ele_per_thread ; i++) {        temp[i] += temp[i-1];    }    warpSum[localId] = temp[(localId+1) * ele_per_thread - 1];    barrier(CLK_LOCAL_MEM_FENCE);    int warpVal = scan_warp(warpSum, blockSize, 1);                             //exclusive    barrier(CLK_LOCAL_MEM_FENCE);    if(lane == MASK)    sumWarpSum[warpId] = warpSum[localId];    barrier(CLK_LOCAL_MEM_FENCE);    if (warpId==0)      scan_warp(sumWarpSum, blockSize/warpSize, 0);           //inclusive: 1024/32 = 32warps    barrier(CLK_LOCAL_MEM_FENCE);        if (warpId > 0)     warpVal += sumWarpSum[warpId-1];     barrier(CLK_LOCAL_MEM_FENCE);    //write back to the global mem    for(int i = 0; i < ele_per_thread ; i++) {        int currentLocalId = localId * ele_per_thread + i;        int currentGlobalId = globalId * ele_per_thread + i;        if (currentGlobalId >= length)  break;        if (isExclusive == 0)             d_source[currentGlobalId] = temp[currentLocalId] + warpVal;        else            d_source[currentGlobalId] = temp[currentLocalId] + warpVal - d_source[currentGlobalId];    }       barrier(CLK_LOCAL_MEM_FENCE);    //write the block sum    if ( isWriteSum==1 && (localId == 0))  {        blockSum[blockId] = d_source[endPlace - 1] + endEle;    }}kernel void scan_addBlock(global int* d_source, uint length, const global int* blockSum, int ele_per_thread){    int localId = get_local_id(0);    int blockId = get_group_id(0);    int blockSize = get_local_size(0);        int startIdx = blockId * blockSize * ele_per_thread;    int thisBlockSum = 0;    if (blockId > 0)    thisBlockSum = blockSum[blockId-1];    for(int i = localId; i < ele_per_thread * blockSize ; i += blockSize) {        d_source[startIdx + i] += thisBlockSum;    }}//deprecated//calculate the smallest power of two larger than inputint ceilPowerOfTwo(uint input) {    int k = 1;    while (k < input) k<<=1;    return k;}//each block can proceed BLOCKSIZE*2 (currently 1024) numberskernel void prefixScan(global int* records,       //size: number of elements                       uint length,                       uint isExclusive,                       local int* temp){    int localId = get_local_id(0);    int globalId = get_global_id(0);    int groupId = get_group_id(0);        temp[2*localId] = 0;                            //initialize to zero for 0 padding    temp[2*localId + 1] = 0;    barrier(CLK_LOCAL_MEM_FENCE);        int offset = 1;                                 //offset: the distance of the two added numbers    int paddedLength = ceilPowerOfTwo(length);      //padding        //memory copy    if (2*localId<length)    temp[2*localId] = records[2*localId];    if (2*localId+1<length)  temp[2*localId+1] = records[2*localId+1];    barrier(CLK_LOCAL_MEM_FENCE);        //reduce    for(int d = paddedLength >> 1; d > 0; d >>=1) {        barrier(CLK_LOCAL_MEM_FENCE);        if (localId < d) {            int ai = offset * ( 2 * localId + 1 ) - 1;            int bi = offset * ( 2 * localId + 2 ) - 1;            temp[bi] += temp[ai];        }        offset <<= 1;    }    barrier(CLK_LOCAL_MEM_FENCE);        if (localId == 0)    {        temp[paddedLength-1] = 0;    }    barrier(CLK_LOCAL_MEM_FENCE);        //sweep down    for(int d = 1; d < paddedLength; d <<= 1) {        offset >>= 1;        if (localId < d) {            int ai = offset * (2 * localId + 1) -1;            int bi = offset * (2 * localId + 2) -1;                        int t = temp[ai];            temp[ai] = temp[bi];            temp[bi] += t;        }        barrier(CLK_LOCAL_MEM_FENCE);    }        if (isExclusive == 1) {     //exclusive        //memory output        if (2*localId<length)    records[2*localId] = temp[2*localId];        if (2*localId+1<length)  records[2*localId+1] = temp[2*localId+1];    }    else {                      //inclusive        //memory output        if (2*localId<length)    records[2*localId] += temp[2*localId];        if (2*localId+1<length)  records[2*localId+1] += temp[2*localId+1];    }}//scan large array: parittion into blocks, each block proceeds 1024 numbers.kernel void scanLargeArray(global int* records,           //size: number of elements                           uint length,                           uint isExclusive,                           local int* temp,             //local memory used                           uint tempSize,                           global uint* blockSum)       //store the sums of each block{    int localId = get_local_id(0);    int globalId = get_global_id(0);    int groupId = get_group_id(0);        temp[2*localId] = 0;                            //initialize to zero for 0 padding    temp[2*localId + 1] = 0;    barrier(CLK_LOCAL_MEM_FENCE);        int offset = 1;                                 //offset: the distance of the two added numbers        //memory copy    if (2*globalId<length)    temp[2*localId] = records[2*globalId];    if (2*globalId+1<length)  temp[2*localId+1] = records[2*globalId+1];        //reduce    for(int d = tempSize >> 1; d > 0; d >>=1) {        barrier(CLK_LOCAL_MEM_FENCE);        if (localId < d) {            int ai = offset * ( 2 * localId + 1 ) - 1;            int bi = offset * ( 2 * localId + 2 ) - 1;            temp[bi] += temp[ai];        }        offset <<= 1;    }        if (localId == 0)   {        blockSum[groupId] = temp[tempSize-1];              //write the sum        temp[tempSize-1] = 0;    }    barrier(CLK_LOCAL_MEM_FENCE);        //sweep down    for(int d = 1; d < tempSize; d <<= 1) {        offset >>= 1;        barrier(CLK_LOCAL_MEM_FENCE);        if (localId < d) {            int ai = offset * (2 * localId + 1) -1;            int bi = offset * (2 * localId + 2) -1;                        int t = temp[ai];            temp[ai] = temp[bi];            temp[bi] += t;        }    }    barrier(CLK_LOCAL_MEM_FENCE);        if (isExclusive == 1) {        //memory output        if (2*globalId<length)    records[2*globalId] = temp[2*localId];        if (2*globalId+1<length)  records[2*globalId+1] = temp[2*localId+1];    }    else {        //memory output        if (2*globalId<length)    records[2*globalId] += temp[2*localId];        if (2*globalId+1<length)  records[2*globalId+1] += temp[2*localId+1];    }}kernel void addBlock(global int* records,                     uint length,                     global int* blockSum,                     local int* temp){    int localId = get_local_id(0);    int globalId = get_global_id(0);    int groupId = get_group_id(0);        temp[2*localId] = 0;    temp[2*localId+1] = 0;    barrier(CLK_LOCAL_MEM_FENCE);        //memory copy    if (2*globalId<length)    temp[2*localId] = records[2*globalId];    if (2*globalId+1<length)  temp[2*localId+1] = records[2*globalId+1];    barrier(CLK_LOCAL_MEM_FENCE);        int thisBlockSum = 0;        if (groupId > 0) {        thisBlockSum = blockSum[groupId-1];        if (2*globalId < length)        temp[2*localId] += thisBlockSum;        if (2*globalId + 1 < length)    temp[2*localId + 1] += thisBlockSum;    }    barrier(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);        if (2*globalId < length)        records[2*globalId] = temp[2*localId];    if (2*globalId + 1 < length)    records[2*globalId + 1] = temp[2*localId+1];}