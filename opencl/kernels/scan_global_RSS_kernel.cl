/* * Design of reduce-scan-scan: *     total length = SCAN_ELE_PER_THREAD * local_size * grid_size *     len_per_wg = SCAN_ELE_PER_THREAD * local_size * The SCAN_ELE_PER_THREAD and local_size are set, then grid_size is set * The reduction and scan_exclusive kernels have the same grid_size */#include "../params.h"#ifndef REDUCE_ELE_PER_WG#define REDUCE_ELE_PER_WG (1)#endif#ifndef SCAN_ELE_PER_LOOP#define SCAN_ELE_PER_LOOP (1)#endif#ifndef MAX_NUM_REGS#define MAX_NUM_REGS (1)#endifint findLog2(int input) {    int lookup[21] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576};    int start = 0, end = 21, middle = (start+end)/2;    while(lookup[middle] != input) {        if (start >= end)   return -1;        if (input > lookup[middle])  start = middle+1;        else                         end = middle-1;        middle = (start+end)/2;    }    return middle;}/*local_size must be the power of 2*/void compute_mixed_access(        unsigned step, unsigned global_id, unsigned global_size, unsigned len_total,        unsigned *begin, unsigned *end){    int step_log = findLog2(step);    int tile = (len_total + global_size - 1) / global_size;    int warp_id = global_id >> step_log;    *begin = warp_id * step * tile + (global_id & (step-1));    *end = (warp_id + 1) * step * tile;    if ((*end) > len_total)    *end = len_total;}void local_warp_scan(local int* lo, int len_total, local int *sum) {    const int local_id = get_local_id(0);                   //should have sign    if (local_id >= len_total)   return;    const unsigned local_size = get_local_size(0);    const char warp_id = local_id >> WARP_BITS;             //warp ID    const unsigned num_warps = local_size >> WARP_BITS;     //# warps    const int lane = local_id & MASK;                       //should have sign    int temp;#define MAX_SUM_SIZE    (32)    local int sums[MAX_SUM_SIZE];       //local temporary sums    //1. Local warp-wise scan    temp = lo[local_id];//    barrier(CLK_LOCAL_MEM_FENCE);       /*need a barrier here*/    if (lane >= 1) lo[local_id] += lo[local_id - 1];    if (lane >= 2) lo[local_id] += lo[local_id - 2];    if (lane >= 4) lo[local_id] += lo[local_id - 4];    if (lane >= 8) lo[local_id] += lo[local_id - 8];    if (lane >= 16) lo[local_id] += lo[local_id - 16];    if (lane == WARP_SIZE - 1) sums[warp_id] = lo[local_id];   //get the warp sum    lo[local_id] -= temp;                                      //exclusive minus    barrier(CLK_LOCAL_MEM_FENCE);    //2. Scan the intermediate sums    if (warp_id == 0 && (local_id < num_warps)) {        temp = sums[local_id];        if (lane >= 1)      sums[local_id] += sums[local_id- 1];        if (lane >= 2)      sums[local_id] += sums[local_id-2];        if (lane >= 4)      sums[local_id] += sums[local_id-4];        if (lane >= 8)      sums[local_id] += sums[local_id-8];        if (lane >= 16)     sums[local_id] += sums[local_id-16];        if ((sum != NULL) && (lane == 0))  *sum = sums[num_warps-1]; /*only lane 0 does the work!!*/        sums[local_id] -= temp;    }    barrier(CLK_LOCAL_MEM_FENCE);    //3. Add back    lo[local_id] += sums[warp_id];    barrier(CLK_LOCAL_MEM_FENCE);#undef MAX_SUM_SIZE}/*in-place local matrix scan in a WG by local_size WIs*/void local_matrix_scan(local int *d_inout, const uint len_total, local int *total_sum){    int local_id = get_local_id(0);    int local_size = get_local_size(0);    int tile_size = (len_total + local_size - 1) / local_size;    if (len_total <= local_size) {  /*use local scan directly*/        local_warp_scan(d_inout, len_total, total_sum);        return;    }    /*now len_total > local_size*/    int reg[MAX_NUM_REGS], temp_store, acc = 0;    /*RSS scheme*/    uint offset = local_id * tile_size;    if (offset + tile_size > len_total) /*eliminate the branch*/        tile_size = len_total - offset;    for(int i = 0; i < tile_size; i++) {        reg[i] = d_inout[offset+i];        acc += reg[i];    }    barrier(CLK_LOCAL_MEM_FENCE);    temp_store = d_inout[local_id]; /*switch the first local_size tuples to regs*/    d_inout[local_id] = acc;    barrier(CLK_LOCAL_MEM_FENCE);    /*local scan scheme*/    local_warp_scan(d_inout, local_size, total_sum);    /*final scan in the registers*/    acc = d_inout[local_id];    /*switch back the local_size tuples to regs*/    d_inout[local_id] = temp_store;    barrier(CLK_LOCAL_MEM_FENCE);    for(int i = 0; i < tile_size; i++) {        d_inout[offset+i] = acc;        acc += reg[i];    }    barrier(CLK_LOCAL_MEM_FENCE);}/* ----------------------- reduce-scan-scan kernels ------------------ */kernelvoid reduce(const global int *d_in,            global int *reduction,          //reduction value for each WG            const uint length_total,        //total number of elements            local int *temp) {              //local reduction values (# WGs)    auto local_id = get_local_id(0);    auto local_size = get_local_size(0);    auto group_id = get_group_id(0);    auto offset = group_id * REDUCE_ELE_PER_WG;    if (local_id >= length_total)   return;    if (offset >= length_total)     return;    uint start, end, step = WARP_SIZE;    compute_mixed_access(step, local_id, local_size,                         REDUCE_ELE_PER_WG, &start, &end);    if (end + offset > length_total)    end = length_total - offset;    int acc = 0;    for(int i = start; i < end; i += step) {        acc += d_in[offset + i];    }    temp[local_id] = acc;    for (uint scale = local_size / 2; scale >= 1; scale >>= 1) {        barrier(CLK_LOCAL_MEM_FENCE);        if (local_id < scale)            temp[local_id] += temp[local_id + scale];    }    if (local_id == 0)  reduction[group_id] = temp[0];}/*Scan with a single WG*/kernelvoid scan_exclusive_small(global int *d_in,                          global int *d_out,                          const uint len_total,                          local int *ldata) {       /*size: len_total*sizeof(int)*/    int local_id = get_local_id(0);    int local_size = get_local_size(0);    /*data transferred to local memory*/    uint begin, end, step = WARP_SIZE;    compute_mixed_access(step, local_id, local_size,                         len_total, &begin, &end);    for(int i = begin; i < end; i += step) ldata[i] = d_in[i];    barrier(CLK_LOCAL_MEM_FENCE);    local_matrix_scan(ldata, len_total, NULL);    /*copy to global memory*/    for(int i = begin; i < end; i += step) d_out[i] = ldata[i];}kernelvoid scan_exclusive(global int *d_in,                    global int *d_out,                    global const int *offsets_global,   //offset for each WG                    uint len_per_wg,                    //elements processed by each WG                    uint length_total,                  //total number of elements                    local int *wi_local_scan) {         //store the temporal local data for scanning    auto local_id = get_local_id(0);    auto local_size = get_local_size(0);    auto group_id = get_group_id(0);    int wg_begin = group_id * len_per_wg;    int wg_end = wg_begin + len_per_wg;    if (wg_end > length_total)  wg_end = length_total;    int acc_tile = offsets_global[group_id];    local int tile_sum;    uint start, end, step = WARP_SIZE;    compute_mixed_access(step, local_id, local_size,                         SCAN_ELE_PER_LOOP, &start, &end);    start += wg_begin;    end += wg_begin;    for (uint tile_ptr = wg_begin; tile_ptr < wg_end; tile_ptr += SCAN_ELE_PER_LOOP) {        for(int addr = start; addr < end; addr += step) {            wi_local_scan[addr-tile_ptr] = d_in[addr];        }        barrier(CLK_LOCAL_MEM_FENCE);        /*scan SCAN_ELE_PER_LOOP elements locally*/        local_matrix_scan(wi_local_scan, SCAN_ELE_PER_LOOP, &tile_sum);        for(int addr = start; addr < end; addr += step)            d_out[addr] = wi_local_scan[addr-tile_ptr] + acc_tile;        acc_tile += tile_sum;        start += SCAN_ELE_PER_LOOP;        end += SCAN_ELE_PER_LOOP;        if (start >= wg_end)    break;        if (end >= wg_end)      end = wg_end;        barrier(CLK_LOCAL_MEM_FENCE);    }}