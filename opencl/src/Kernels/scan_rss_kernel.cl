/* * Design of reduce-scan-scan: *     total length = SCAN_ELE_PER_THREAD * local_size * grid_size *     len_per_wg = SCAN_ELE_PER_THREAD * local_size * The SCAN_ELE_PER_THREAD and local_size are set, then grid_size is set * The reduction and scan_exclusive kernels have the same grid_size */#include "params.h"inline void local_serial_scan(local int* lo, int length, local int *sum) {    int localId = get_local_id(0);    if (localId == 0) {        int sum1 = lo[0];        lo[0] = 0;        for(int i = 1; i < length; i++) {            int cur = lo[i];            lo[i] = sum1;            sum1 += cur;        }        *sum = sum1;    }    barrier(CLK_LOCAL_MEM_FENCE);}inline void local_serial_scan_multithread(local int* lo, int length, local int *sum) {    int localId = get_local_id(0);    int thread_used = 128;    int ele_per_thread = length/thread_used;    local int tempSums[128];    //1.reduce    if (localId < thread_used) {        int start = localId * ele_per_thread;        int sum1 = 0;        for(int i = 0; i < ele_per_thread; i++) {            sum1 += lo[start+i];        }        tempSums[localId] = sum1;    }    barrier(CLK_LOCAL_MEM_FENCE);    //2.scan    if (localId == 0) {        int local_temp0 = tempSums[0];        tempSums[0] = 0;        for(int r = 1; r < thread_used; r++) {            int local_temp1 = tempSums[r];            tempSums[r] = local_temp0 + tempSums[r-1];            local_temp0 = local_temp1;        }        *sum = local_temp0 + tempSums[thread_used-1];    }    barrier(CLK_LOCAL_MEM_FENCE);    //3.scan    if (localId < thread_used) {        int start = localId * ele_per_thread;        int local_temp0 = lo[start];        lo[start] = tempSums[localId];        for(int r = 1; r < ele_per_thread; r++) {            int local_temp1 = lo[r+start];            lo[r+start] = local_temp0 + lo[r+start-1];            local_temp0 = local_temp1;        }    }    barrier(CLK_LOCAL_MEM_FENCE);}inline void scan_local(local int* lo, int ele_per_thread, local int* totalSum) {    const unsigned localId = get_local_id(0);    const unsigned localSize = get_local_size(0);    int tempStore;  //to store the first 1024 elements in the original lo array    int tempSum;    int row_start, row_end;    //notice: when using conflict-free blelloch scan sub-scheme, remove the if statement    if (ele_per_thread != 1) {      //if ele_per_thread==1, skip the serial reduction        //1. Reduction (per thread)        row_start = localId * ele_per_thread;        row_end = (localId + 1) * ele_per_thread;        int local_sum = 0;        for (int r = row_start; r < row_end; r++) {            local_sum += lo[r];        }        barrier(CLK_LOCAL_MEM_FENCE);        tempStore = lo[localId]; //for bank-conflict-free blelloch scan        lo[localId] = local_sum; //for bank-conflict-free blelloch scan        barrier(CLK_LOCAL_MEM_FENCE);    }    local_serial_scan_multithread(lo,localSize, totalSum);    if (ele_per_thread != 1) {      //if ele_per_thread==1, skip the serial scan        tempSum = lo[localId];        lo[localId] = tempStore; //switch back the first localSize elements        barrier(CLK_LOCAL_MEM_FENCE);        //3. Scan        int local_temp0 = lo[row_start];        lo[row_start] = tempSum;        for (int r = row_start + 1; r < row_end; r++) {            int local_temp1 = lo[r];            lo[r] = local_temp0 + lo[r - 1];            local_temp0 = local_temp1;        }    }    barrier(CLK_LOCAL_MEM_FENCE);}/* ----------------------- reduce-scan-scan kernels (complicated) ------------------ */kernel void reduce(        const global int *d_in,//input data        global int *reduction,          //reduction value for each WG        const uint length_total,        //total number of elements        local int *temp)                //local reduction values (# WGs){    const uint local_id = get_local_id(0);    const uint local_size = get_local_size(0);    const uint group_id = get_group_id(0);    const uint wavefront_id = local_id >> WARP_BITS;      //wavefront ID    const uint lane = local_id & SCAN_MASK;          //lane ID in the wavefront    int len_per_wg = local_size * REDUCE_ELE_PER_WI;      //number of elements processed by each WG    const uint offset = group_id*len_per_wg;    const uint start = offset + wavefront_id * SCAN_WARPSIZE * REDUCE_ELE_PER_WI;    uint end = offset + (wavefront_id+1)* SCAN_WARPSIZE * REDUCE_ELE_PER_WI;    if (end > length_total)  end = length_total;    int acc = 0;    int c = start + lane;    while (c < end) {        acc += d_in[c];        c += SCAN_WARPSIZE;    }    temp[local_id] = acc;    for (uint scale = local_size / 2; scale >= 1; scale >>= 1)    {        barrier(CLK_LOCAL_MEM_FENCE);        if (local_id < scale)            temp[local_id] += temp[local_id + scale];    }    if (local_id == 0)  reduction[group_id] = temp[0];}//second exclusive scan step, only handle #wgs elements, single WGkernel void scan_exclusive_small(        global int *d_in,               //input        global int *d_out,              //output        const uint len,                      //length of the elements        local int* temp)                //to perform local scan on{    const uint local_id = get_local_id(0);    const uint local_size = get_local_size(0);    const uint group_id = get_group_id(0);    const uint wavefront_id = local_id >> WARP_BITS;      //wavefront ID    const uint lane = local_id & SCAN_MASK;          //lane ID in the wavefront    const uint ele_per_wi = (len + local_size-1)/local_size;    int runs = (len + local_size - 1)/ local_size;    //the scan can only handle local_size elements    int acc = 0;    local int local_sum;    if (len <= local_size) {        local_sklansky_scan(temp, len, &local_sum);        return ;    }    for(int r = 0; r < runs; r++) {        int start_of_run = r*local_size;        const uint start = wavefront_id * SCAN_WARPSIZE * ele_per_wi;        uint end = (wavefront_id+1)* SCAN_WARPSIZE * ele_per_wi;//        if (end > len)  end = len;        if (end > local_size)  end = local_size;        /*copy to the local memory*/        uint c = start + lane;        while (c < end) {            temp[c] = d_in[start_of_run+c];            c += SCAN_WARPSIZE;        }        local_sklansky_scan(temp, local_size, &local_sum);        /*write back*/        c = start + lane;        while (c < end) {            d_out[start_of_run+c] = temp[c] + acc;            c += SCAN_WARPSIZE;        }        acc += local_sum;        barrier(CLK_LOCAL_MEM_FENCE);    }}kernel void scan_exclusive(        global const int *d_inout,             //input data        global const int *offsets_global,   //offset for each wg        uint len_per_wg,                    //elements processed by each WG        uint length_total,                  //total number of elements        local int *wi_local_scan)           //store the temporal local data for scanning{    const uint local_id = get_local_id(0);    const uint local_size = get_local_size(0);    const uint group_id = get_group_id(0);    const uint group_num = get_num_groups(0);    const uint wavefront_id = local_id >> WARP_BITS;      //wavefront ID    const uint lane = local_id & SCAN_MASK;          //lane ID in the wavefront    int wg_begin = group_id * len_per_wg;    int wg_end = (group_id+1) * len_per_wg;    if (wg_end > length_total)  wg_end = length_total;    int offset = offsets_global[group_id];    int acc_tile = 0;    local int tile_sum;    for (uint tile_begin = wg_begin; tile_begin < wg_end; tile_begin += SCAN_ELE_PER_WI*local_size) {        const uint start =  wavefront_id * SCAN_WARPSIZE * SCAN_ELE_PER_WI;        uint end = (wavefront_id+1)* SCAN_WARPSIZE * SCAN_ELE_PER_WI;        if (end > SCAN_ELE_PER_WI*local_size)  end = SCAN_ELE_PER_WI*local_size;        /*read the scan the private registers*/        int c = start + lane;        while (c < end) {            wi_local_scan[c] = d_inout[tile_begin+c];            c += SCAN_WARPSIZE;        }        barrier(CLK_LOCAL_MEM_FENCE);        scan_local(wi_local_scan, SCAN_ELE_PER_WI, &tile_sum);        /* write back to the global mem, need to add: offset, wi_local_sum and acc_tile  */        c = start + lane;        while (c < end) {            d_inout[tile_begin+c] = wi_local_scan[c] + acc_tile + offset;            c += SCAN_WARPSIZE;        }        acc_tile += tile_sum;        barrier(CLK_LOCAL_MEM_FENCE);    }}/*simple reduce-scan-scan scheme, for CPUs and MICs*/kernel void reduce_single(        global int *d_in,        global int *reduction,          //reduction value for each WG        uint len_per_wg,        const uint length_total){    const int group_id = get_group_id(0);    const uint start =  len_per_wg*group_id;    uint end = (group_id+1)* len_per_wg;    if (end > length_total)  end = length_total;    int acc = 0;    for(int i = start; i < end; i++) {        acc += d_in[i];    }    reduction[group_id] = acc;}kernel void scan_no_offset_single(        global int *d_inout,             //input data        uint length_total){    int acc = d_inout[0];    d_inout[0] = 0;    for(int i = 1; i < length_total; i++) {        int temp = d_inout[i];        d_inout[i] = acc;        acc += temp;    }}kernel void scan_with_offset_single(        global int *d_in,             //input data        global int *d_out,             //output data        global const int *offsets_global,   //offset for each wg        uint len_per_wg,                    //elements processed by each WG        uint length_total){    const int group_id = get_group_id(0);    const uint start =  len_per_wg*group_id;    uint end = (group_id+1)* len_per_wg;    if (end > length_total)  end = length_total;    int offset = offsets_global[group_id];    if (start >= length_total)   return;    d_out[start] = offset;    for(int i = start+1; i < end; i++) {        d_out[i] = d_out[i-1] + d_in[i-1];    }}