/* * Design of reduce-scan-scan: *     total length = SCAN_ELE_PER_THREAD * local_size * grid_size *     len_per_wg = SCAN_ELE_PER_THREAD * local_size * The SCAN_ELE_PER_THREAD and local_size are set, then grid_size is set * The reduction and scan_exclusive kernels have the same grid_size */#include "params.h"#include "scan_local.cl"/*local_size must be the power of 2*/void compute_mixed_access(        unsigned step, unsigned global_id, unsigned global_size, unsigned len_total,        unsigned *begin, unsigned *end){    int step_log = findLog2(step);    int tile = (len_total + global_size - 1) / global_size;    int warp_id = global_id >> step_log;    *begin = warp_id * step * tile + (global_id & (step-1));    *end = (warp_id + 1) * step * tile;    if ((*end) > len_total)    *end = len_total;}/* ----------------------- reduce-scan-scan kernels (complicated) ------------------ */kernel void reduce(        const global int *d_in,//input data        global int *reduction,          //reduction value for each WG        const uint length_total,        //total number of elements        local int *temp)                //local reduction values (# WGs){    const uint local_id = get_local_id(0);    const uint local_size = get_local_size(0);    const uint group_id = get_group_id(0);    const uint wavefront_id = local_id >> WARP_BITS;      //wavefront ID    const uint lane = local_id & MASK;      //lane ID in the wavefront    int offset = group_id * REDUCE_ELE_PER_WG;    uint start, end, step = WARP_SIZE;    compute_mixed_access(            step, local_id, local_size, REDUCE_ELE_PER_WG,            &start, &end);    int acc = 0;    for(int i = start; i < end; i += step)        acc += d_in[offset + i];    temp[local_id] = acc;    for (uint scale = local_size / 2; scale >= 1; scale >>= 1)    {        barrier(CLK_LOCAL_MEM_FENCE);        if (local_id < scale)            temp[local_id] += temp[local_id + scale];    }    if (local_id == 0)  reduction[group_id] = temp[0];}//second exclusive scan step, only handle #wgs elements, single WGkernel void scan_exclusive_small(        global int *d_in,               //input        global int *d_out,              //output        const uint len,                      //length of the elements        local int* temp)                //to perform local scan on{    const uint local_id = get_local_id(0);    const uint local_size = get_local_size(0);    const uint group_id = get_group_id(0);    const uint wavefront_id = local_id >> WARP_BITS;      //wavefront ID    const uint lane = local_id & MASK;          //lane ID in the wavefront    const uint ele_per_wi = (len + local_size-1)/local_size;    int runs = (len + local_size - 1)/ local_size;    //the scan can only handle local_size elements    int acc = 0;    local int local_sum;    if (len <= local_size) {        local_sklansky_scan(temp, len, &local_sum);        return ;    }    for(int r = 0; r < runs; r++) {        int start_of_run = r*local_size;        const uint start = wavefront_id * WARP_SIZE * ele_per_wi;        uint end = (wavefront_id+1)* WARP_SIZE * ele_per_wi;        if (end > local_size)  end = local_size;        /*copy to the local memory*/        uint c = start + lane;        while (c < end) {            temp[c] = d_in[start_of_run+c];            c += WARP_SIZE;        }        local_sklansky_scan(temp, local_size, &local_sum);        /*write back*/        c = start + lane;        while (c < end) {            d_out[start_of_run+c] = temp[c] + acc;            c += WARP_SIZE;        }        acc += local_sum;        barrier(CLK_LOCAL_MEM_FENCE);    }}kernel void scan_exclusive(        global int *d_in,        global int *d_out,        global const int *offsets_global,   //offset for each wg        uint len_per_wg,                    //elements processed by each WG        uint length_total,                  //total number of elements        local int *wi_local_scan)           //store the temporal local data for scanning{    const uint local_id = get_local_id(0);    const uint local_size = get_local_size(0);    const uint group_id = get_group_id(0);    const uint group_num = get_num_groups(0);    const uint wavefront_id = local_id >> WARP_BITS;      //wavefront ID    const uint lane = local_id & MASK;          //lane ID in the wavefront    int wg_begin = group_id * len_per_wg;    int wg_end = (group_id+1) * len_per_wg;    if (wg_end > length_total)  wg_end = length_total;    int offset = offsets_global[group_id];    int acc_tile = 0;    local int tile_sum;    uint start, end, step = WARP_SIZE;    compute_mixed_access(            step, local_id, local_size, SCAN_ELE_PER_WI*local_size,            &start, &end);    /*in each iteration, the WG processes SCAN_ELE_PER_WI * local_size elements*/    for (uint tile_ptr = wg_begin; tile_ptr < wg_end; tile_ptr += SCAN_ELE_PER_WI*local_size) {        /*read the scan the private registers*/        for(int i = start; i < end; i += step) {            uint addr = tile_ptr + i;            wi_local_scan[i] = (addr < length_total) ? d_in[addr] : 0;        }        barrier(CLK_LOCAL_MEM_FENCE);        if (local_id == 0) {            int acc = 0;            for(int i = 0; i < SCAN_ELE_PER_WI*local_size; i++) {                int temp = wi_local_scan[i];                wi_local_scan[i] = acc;                acc += temp;            }            tile_sum = acc;        }        barrier(CLK_LOCAL_MEM_FENCE);        /*this is wrong*///        scan_local(wi_local_scan, SCAN_ELE_PER_WI, &tile_sum);        for(int i = start; i < end; i += step) {            uint addr = tile_ptr + i;            if (addr < length_total) {                d_out[addr] = wi_local_scan[i] + acc_tile + offset;            }        }        acc_tile += tile_sum;        barrier(CLK_LOCAL_MEM_FENCE);    }}