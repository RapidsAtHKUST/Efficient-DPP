#include "dataDef.h"/*********************** Start of 2n-movement StreamScan ***********************************///adjacent synchronization functioninline void adjSyn(int blockId, int localId, global volatile int *inter, local int* r, local int *s){    if (localId == 0) {        int p = 0;        if (blockId == 0)   inter[0] = (*r);        else {            while ((p = inter[blockId-1]) == -1) {}            inter[blockId] = p + (*r);        }        *s = p;    }    barrier(CLK_LOCAL_MEM_FENCE);}//serial scan for private registersint private_scan_serial(int *re, int length, int isExclusive) {    if (isExclusive) {        int sum = re[0];        re[0] = 0;        for(int i = 1; i < length; i++) {            int cur = re[i];            re[i] = sum;            sum += cur;        }        return sum;    }    else {        for(int i = 1; i < length; i++) {            re[i] += re[i-1];        }        return re[length-1];    }}//warp-wise scan: inclusiveinline void local_scan_warp_in(local int* lo, int length, int beginIdx, int lane, int elements_per_thread, local int *sum) {    int c = beginIdx + lane;    int end = beginIdx + elements_per_thread * SCAN_WARPSIZE;    if (end > length)   end = length;    int acc = 0;    while (c < end) {        //scan the data warp just came        if (lane >= 1)      lo[c] += lo[c-1];        if (lane >= 2)      lo[c] += lo[c-2];        if (lane >= 4)      lo[c] += lo[c-4];        if (lane >= 8)      lo[c] += lo[c-8];        if (lane >= 16)     lo[c] += lo[c-16];  //can cover warpsize=32        lo[c] += acc;        acc = lo[(SCAN_WARPSIZE - 1 - lane)+c];        if ((lane == SCAN_WARPSIZE - 1) || (c == length-1))             *sum = lo[c];        c += SCAN_WARPSIZE;    }   }inline void local_scan_warp_ex(local int* lo, int length, int beginIdx, int lane, int elements_per_thread, local int *sum) {    // lane = get_local_id(0) & (SCAN_WARPSIZE-1);    int c = beginIdx + lane;    // int end = beginIdx + elements_per_thread * SCAN_WARPSIZE;    // if (end > length)   end = length;        int acc = 0;    // int temp;    for(int i = 0; i < elements_per_thread; i++) {        if (c < length) {            int temp = lo[c];            //scan the data warp just came            if (lane >= 1)      lo[c] += lo[c-1];            if (lane >= 2)      lo[c] += lo[c-2];            if (lane >= 4)      lo[c] += lo[c-4];            if (lane >= 8)      lo[c] += lo[c-8];            if (lane >= 16)     lo[c] += lo[c-16];  //can cover warpsize=32            lo[c] += acc;            acc = lo[(SCAN_WARPSIZE - 1 - lane)+c];            if ((lane == SCAN_WARPSIZE - 1) || (c == length-1))                 *sum = lo[c];            lo[c] = lo[c] - temp ;            c += SCAN_WARPSIZE;        }       }}inline void local_scan_serial(local int* lo, int length, local int *sum, int isExclusive) {    int localId = get_local_id(0);    if (localId == 0) {        if (isExclusive) {            int sum1 = lo[0];            lo[0] = 0;            for(int i = 1; i < length; i++) {                int cur = lo[i];                lo[i] = sum1;                sum1 += cur;            }            *sum =  sum1;        }        else {            for(int i = 1; i < length; i++) {                lo[i] += lo[i-1];            }            *sum = lo[length-1];        }    }    barrier(CLK_LOCAL_MEM_FENCE);}/* * scan_fast: the fast 2n read-write scan * para: *      d_source: input array *      length: length of the input array *      lo: local memory for scan *      gss: accumulated sum from the previous group *      help: local helping memory for intermediate scan within a group *      num_of_groups: number of groups needed to be scanned *      R: number of elements each thread has in the registers *      L: number of elements in the local memory *      isExclusive: whether it is exclusive *      inter: global intermediate array to spread the accumulated sums */kernel void scan_fast(    global int * restrict d_source, const int length,    local int *lo, const int lo_size,     local int* gs, local int *gss, local int* help,    const int num_of_groups, const int R, const int L,    const int isExclusive, global int * restrict inter){    int localId = get_local_id(0);    int localSize = get_local_size(0);    int groupId = get_group_id(0);    int groupSize = get_global_size(0) / get_local_size(0);    int re[REGISTERS];    //SCAN_BITS(5-> warpsize=32)    const unsigned warpId = localId >> SCAN_BITS;      //warp ID    const unsigned warpNum = localSize >> SCAN_BITS;   //# warps    const unsigned lane = localId & SCAN_MASK;        const unsigned elements_per_thread = (lo_size + localSize - 1) / localSize;    const unsigned L_elements_per_thread = (L + localSize - 1) / localSize;    const unsigned temp_ele_per_thread = (warpNum + SCAN_WARPSIZE - 1) / SCAN_WARPSIZE;    const unsigned beginIdx = warpId * SCAN_WARPSIZE * elements_per_thread;    const unsigned L_beginIdx = warpId * SCAN_WARPSIZE * L_elements_per_thread;    int c,end;    for(int w = groupId; w < num_of_groups; w += groupSize)    {        int lStart = (localSize * R + L) * w;        int rStart = lStart + L;                //load to local memory and then to private registers        if (R != 0) {            c = warpId * SCAN_WARPSIZE * R + lane;            for(int r = 0; r < R; r++) {                if (rStart + c >= length)   break;                lo[c] = d_source[rStart + c];                c += SCAN_WARPSIZE;            }            barrier(CLK_LOCAL_MEM_FENCE);            //from local memory to registers            c = localId * R;            for(int r = 0; r < R; r++) {                re[r] = lo[c+r];            }            barrier(CLK_LOCAL_MEM_FENCE);            //serial scan and return the sum            lo[L+localId] = private_scan_serial(re, R, isExclusive);            barrier(CLK_LOCAL_MEM_FENCE);        }        //load to local memory        c = L_beginIdx + lane;        for(int i = 0; i < L_elements_per_thread; i++) {            // if (lStart + c < length) {                lo[c] = d_source[lStart + c];                c += SCAN_WARPSIZE;             // }         }        barrier(CLK_LOCAL_MEM_FENCE);//local memory warp scan         if (isExclusive)            local_scan_warp_ex(lo, lo_size,beginIdx, lane, elements_per_thread, help+warpId);        else             local_scan_warp_in(lo, lo_size,beginIdx, lane, elements_per_thread, help+warpId);        barrier(CLK_LOCAL_MEM_FENCE);        //scan the intermediate help array with warpNum elements, exclusive        if (warpId == 0)  {                local_scan_warp_ex(help, warpNum, 0, lane, temp_ele_per_thread, gs);        }        adjSyn(w, localId, inter, gs, gss);   //adjacent sync        //add back the help array to the local momery         c = beginIdx + lane;        for(int i = 0; i < elements_per_thread; i++) {            // if (c < lo_size) {                lo[c] += help[warpId];                c += SCAN_WARPSIZE;            // }        }        barrier(CLK_LOCAL_MEM_FENCE);            //local memory serial scan        // local_scan_serial(lo, lo_size, gs, isExclusive);        // adjSyn(w, localId, inter, gs, gss);   //adjacent sync        // barrier(CLK_LOCAL_MEM_FENCE);        // add back and copy the local mem to d_source        c = L_beginIdx + lane;        for(int i = 0; i < L_elements_per_thread; i++) {            // if (lStart + c < length) {                d_source[lStart + c] = lo[c] + (*gss);                c += SCAN_WARPSIZE;            // }        }        //add back and copy the registers to local memory        if (R != 0) {            int preSum;            if (localId == 0) {                if (L != 0) preSum = lo[L+isExclusive-1] + (*gss);                else        preSum = (*gss);                for(int r = 0; r < R; r++)                     re[r] += preSum;            }            else {                preSum = lo[L+localId+isExclusive-1] + (*gss);                for(int r = 0; r < R; r++)                     re[r] += preSum;            }            barrier(CLK_LOCAL_MEM_FENCE);            c = localId * R;            for(int r = 0; r < R; r++)                 lo[c+r] = re[r];            barrier(CLK_LOCAL_MEM_FENCE);            //from local memory to global memory            c = warpId * SCAN_WARPSIZE * R + lane;            for(int r = 0; r < R; r++) {                d_source[rStart + c] = lo[c];                c += SCAN_WARPSIZE;            }        }    }}//--------------------------- multi-kernel warp scan -------------//scan_warp: d_source is always been inclusively scanned, the return number is the right output//return: corresponding data of each thread index//scanning BLOCKSIZE elements using parallel scanint scan_warp(local int *d_source, const uint length, int isExclusive) {    int localId = get_local_id(0);    const unsigned int lane = localId & SCAN_MASK;        //warp size is 32    if (localId >= length)  return 0;       if (lane >= 1)      d_source[localId] += d_source[localId-1];    if (lane >= 2)      d_source[localId] += d_source[localId-2];    if (lane >= 4)      d_source[localId] += d_source[localId-4];    if (lane >= 8)      d_source[localId] += d_source[localId-8];    if (lane >= 16)     d_source[localId] += d_source[localId-16];    if (isExclusive == 0)   return d_source[localId];    else                    return (lane > 0)? d_source[localId-1] : 0;}//scan_warp function for MIC//scanning BLOCKSIZE elements using parallel scan//for MIC, the warp size should be 16. //ATTENTION: the local size for MIC is at most 16 * 16 = 256int scan_warp_mic(local int *d_source, int length, int isExclusive) {    int localId = get_local_id(0);    const unsigned int lane = localId & SCAN_MASK;        //warp size is 16    if (localId >= length)  return 0;       if (lane >= 1)      d_source[localId] += d_source[localId-1];    if (lane >= 2)      d_source[localId] += d_source[localId-2];    if (lane >= 4)      d_source[localId] += d_source[localId-4];    if (lane >= 8)      d_source[localId] += d_source[localId-8];    if (isExclusive == 0)   return d_source[localId];    else                    return (lane > 0)? d_source[localId-1] : 0;}//each block can process up to 1024*8=8192 elements if 1024 threads are used//return: the sum of this block of data(only true when it is a inclusive scan)kernel void scan_block(    global int *d_source,     const int length,     int isExclusive,    int isWriteSum,     global int *blockSum,    int numOfWarps,    local int* temp,            //global data used in this block    local int* warpSum,    local int* sumWarpSum)      //size: numOfWarps{    int localId = get_local_id(0);    int globalId = get_global_id(0);    int blockSize = get_local_size(0);    int blockId = get_group_id(0);    const unsigned int lane = localId & SCAN_MASK;    const unsigned int warpId = localId >> SCAN_BITS;    //global mem to shared mem, coalesced access    int startIdx = blockId * blockSize * SCAN_ELE_PER_THREAD;    for(int i = localId; i < SCAN_ELE_PER_THREAD * blockSize ; i += blockSize) {        if (startIdx + i >= length) break;        temp[i] = d_source[startIdx + i];    }    barrier(CLK_LOCAL_MEM_FENCE);    //endPlace: ending index of the part this block process    int endPlace = (blockId+1)*blockSize*SCAN_ELE_PER_THREAD >= length?  length : (blockId+1)*blockSize*SCAN_ELE_PER_THREAD;    int endEle = 0;    if ( isWriteSum ==1  && (localId == 0) && isExclusive == 1)   endEle = d_source[endPlace-1];    barrier(CLK_LOCAL_MEM_FENCE);    //doing the local scan    for(int i = localId * SCAN_ELE_PER_THREAD + 1; i < (localId + 1) * SCAN_ELE_PER_THREAD ; i++) {        temp[i] += temp[i-1];    }    warpSum[localId] = temp[(localId+1) * SCAN_ELE_PER_THREAD - 1];    barrier(CLK_LOCAL_MEM_FENCE);    int warpVal = scan_warp(warpSum, blockSize, 1);                   //exclusive    barrier(CLK_LOCAL_MEM_FENCE);    if(lane == SCAN_MASK)    sumWarpSum[warpId] = warpSum[localId];    barrier(CLK_LOCAL_MEM_FENCE);    scan_warp(sumWarpSum, numOfWarps, 0);           //inclusive: 1024/32 = 32warps    barrier(CLK_LOCAL_MEM_FENCE);    if (warpId > 0)     warpVal += sumWarpSum[warpId-1];     barrier(CLK_LOCAL_MEM_FENCE);    //write back to the global mem    for(int i = 0; i < SCAN_ELE_PER_THREAD ; i++) {        int currentLocalId = localId * SCAN_ELE_PER_THREAD + i;        int currentGlobalId = globalId * SCAN_ELE_PER_THREAD + i;        if (currentGlobalId >= length)  break;        if (isExclusive == 0)            d_source[currentGlobalId] = temp[currentLocalId] + warpVal;        else            d_source[currentGlobalId] = temp[currentLocalId] + warpVal - d_source[currentGlobalId];    }       barrier(CLK_LOCAL_MEM_FENCE);    //write the block sum    if ( isWriteSum==1 && (localId == 0))  {        blockSum[blockId] = d_source[endPlace - 1] + endEle;    }}//------------------------ multi-kernel blelloch scan -----------void scan_ble_small(local int *d_source, const uint length, int isExclusive){    int localId = get_local_id(0);    if (localId >= length)  return;        int offset = 1;                         //offset: the distance of the two added numbers    //reduce    for(int d = length >> 1; d > 0; d >>=1) {        if (localId < d) {            int ai = offset * ( 2 * localId + 1 ) - 1;            int bi = offset * ( 2 * localId + 2 ) - 1;            d_source[bi] += d_source[ai];        }        offset <<= 1;        barrier(CLK_LOCAL_MEM_FENCE);    }        if (localId == 0)    {        if (isExclusive == 1)            d_source[length-1] = 0;        else            offset >>= 1;    }    barrier(CLK_LOCAL_MEM_FENCE);        //sweep down    if (isExclusive == 1) {        for(int d = 1; d < length; d <<= 1) {            offset >>= 1;            if (localId < d) {                int ai = offset * (2 * localId + 1) -1;                int bi = offset * (2 * localId + 2) -1;                                int t = d_source[ai];                d_source[ai] = d_source[bi];                d_source[bi] += t;            }            barrier(CLK_LOCAL_MEM_FENCE);        }    }    else {        for(int d = 2; d <= length/2; d<<=1) {            offset >>= 1;            if (localId > 0 && localId < d) {                int ai = localId * length / d - 1;                int bi = offset + ai;                d_source[bi] += d_source[ai];            }            barrier(CLK_LOCAL_MEM_FENCE);        }    }}//each block can process up to 1024*8=8192 elements if 1024 threads are used//return: the sum of this block of data(only true when it is a inclusive scan)kernel void scan_ble_large(    global int *d_source,     const uint length,     int isExclusive,     int isWriteSum,     global int *blockSum,    local int* temp,            //global data used in this block    local int* warpSum){    int localId = get_local_id(0);    int globalId = get_global_id(0);    int blockSize = get_local_size(0);    int blockId = get_group_id(0);    //global mem to shared mem, coalesced access    int startIdx = blockId * blockSize * SCAN_ELE_PER_THREAD;    for(int i = localId; i < SCAN_ELE_PER_THREAD * blockSize ; i += blockSize) {        if (startIdx + i >= length) break;        temp[i] = d_source[startIdx + i];    }    barrier(CLK_LOCAL_MEM_FENCE);    //endPlace: ending index of the part this block process    int endPlace = (blockId+1)*blockSize*SCAN_ELE_PER_THREAD >= length?  length : (blockId+1)*blockSize*SCAN_ELE_PER_THREAD;    int endEle = 0;    if ( isWriteSum && (localId == 0) && isExclusive)   endEle = d_source[endPlace-1];    barrier(CLK_LOCAL_MEM_FENCE);    //doing the local scan: each thread does a sequential scan    for(int i = localId * SCAN_ELE_PER_THREAD + 1; i < (localId + 1) * SCAN_ELE_PER_THREAD ; i++) {        temp[i] += temp[i - 1];    }    warpSum[localId] = temp[(localId+1) * SCAN_ELE_PER_THREAD - 1];    barrier(CLK_LOCAL_MEM_FENCE);    scan_ble_small(warpSum, blockSize, 1);      //exclusive scan    //write back to the global mem    for(int i = 0; i < SCAN_ELE_PER_THREAD ; i++) {        int currentLocalId = localId * SCAN_ELE_PER_THREAD + i;        int currentGlobalId = globalId * SCAN_ELE_PER_THREAD + i;        if (currentGlobalId >= length)  break;        if (isExclusive == 0)             d_source[currentGlobalId] = temp[currentLocalId] + warpSum[localId];        else            d_source[currentGlobalId] = temp[currentLocalId] + warpSum[localId] - d_source[currentGlobalId];    }       barrier(CLK_LOCAL_MEM_FENCE);    //write the block sum    if ( isWriteSum && (localId == 0))  {        blockSum[blockId] = d_source[endPlace - 1] + endEle;    }}/*************************** End of Blelloch scan ***************************************/kernel void scan_addBlock(global int* d_source, uint length, const global int* blockSum){    int localId = get_local_id(0);    int blockId = get_group_id(0);    int blockSize = get_local_size(0);        int startIdx = blockId * blockSize * SCAN_ELE_PER_THREAD;    int thisBlockSum = 0;    if (blockId > 0)    thisBlockSum = blockSum[blockId-1];    for(int i = localId; i < SCAN_ELE_PER_THREAD * blockSize ; i += blockSize) {        d_source[startIdx + i] += thisBlockSum;    }}//---------------------------------deprecated-------------------------------//calculate the smallest power of two larger than inputint ceilPowerOfTwo(uint input) {    int k = 1;    while (k < input) k<<=1;    return k;}//each block can proceed BLOCKSIZE*2 (currently 1024) numberskernel void prefixScan(global int* records,       //size: number of elements                       uint length,                       uint isExclusive,                       local int* temp){    int localId = get_local_id(0);    int globalId = get_global_id(0);    int groupId = get_group_id(0);        temp[2*localId] = 0;                            //initialize to zero for 0 padding    temp[2*localId + 1] = 0;    barrier(CLK_LOCAL_MEM_FENCE);        int offset = 1;                                 //offset: the distance of the two added numbers    int paddedLength = ceilPowerOfTwo(length);      //padding        //memory copy    if (2*localId<length)    temp[2*localId] = records[2*localId];    if (2*localId+1<length)  temp[2*localId+1] = records[2*localId+1];    barrier(CLK_LOCAL_MEM_FENCE);        //reduce    for(int d = paddedLength >> 1; d > 0; d >>=1) {        barrier(CLK_LOCAL_MEM_FENCE);        if (localId < d) {            int ai = offset * ( 2 * localId + 1 ) - 1;            int bi = offset * ( 2 * localId + 2 ) - 1;            temp[bi] += temp[ai];        }        offset <<= 1;    }    barrier(CLK_LOCAL_MEM_FENCE);        if (localId == 0)    {        temp[paddedLength-1] = 0;    }    barrier(CLK_LOCAL_MEM_FENCE);        //sweep down    for(int d = 1; d < paddedLength; d <<= 1) {        offset >>= 1;        if (localId < d) {            int ai = offset * (2 * localId + 1) -1;            int bi = offset * (2 * localId + 2) -1;                        int t = temp[ai];            temp[ai] = temp[bi];            temp[bi] += t;        }        barrier(CLK_LOCAL_MEM_FENCE);    }        if (isExclusive == 1) {     //exclusive        //memory output        if (2*localId<length)    records[2*localId] = temp[2*localId];        if (2*localId+1<length)  records[2*localId+1] = temp[2*localId+1];    }    else {                      //inclusive        //memory output        if (2*localId<length)    records[2*localId] += temp[2*localId];        if (2*localId+1<length)  records[2*localId+1] += temp[2*localId+1];    }}//scan large array: parittion into blocks, each block proceeds 1024 numbers.kernel void scanLargeArray(global int* records,           //size: number of elements                           uint length,                           uint isExclusive,                           local int* temp,             //local memory used                           uint tempSize,                           global uint* blockSum)       //store the sums of each block{    int localId = get_local_id(0);    int globalId = get_global_id(0);    int groupId = get_group_id(0);        temp[2*localId] = 0;                            //initialize to zero for 0 padding    temp[2*localId + 1] = 0;    barrier(CLK_LOCAL_MEM_FENCE);        int offset = 1;                                 //offset: the distance of the two added numbers        //memory copy    if (2*globalId<length)    temp[2*localId] = records[2*globalId];    if (2*globalId+1<length)  temp[2*localId+1] = records[2*globalId+1];        //reduce    for(int d = tempSize >> 1; d > 0; d >>=1) {        barrier(CLK_LOCAL_MEM_FENCE);        if (localId < d) {            int ai = offset * ( 2 * localId + 1 ) - 1;            int bi = offset * ( 2 * localId + 2 ) - 1;            temp[bi] += temp[ai];        }        offset <<= 1;    }        if (localId == 0)   {        blockSum[groupId] = temp[tempSize-1];              //write the sum        temp[tempSize-1] = 0;    }    barrier(CLK_LOCAL_MEM_FENCE);        //sweep down    for(int d = 1; d < tempSize; d <<= 1) {        offset >>= 1;        barrier(CLK_LOCAL_MEM_FENCE);        if (localId < d) {            int ai = offset * (2 * localId + 1) -1;            int bi = offset * (2 * localId + 2) -1;                        int t = temp[ai];            temp[ai] = temp[bi];            temp[bi] += t;        }    }    barrier(CLK_LOCAL_MEM_FENCE);        if (isExclusive == 1) {        //memory output        if (2*globalId<length)    records[2*globalId] = temp[2*localId];        if (2*globalId+1<length)  records[2*globalId+1] = temp[2*localId+1];    }    else {        //memory output        if (2*globalId<length)    records[2*globalId] += temp[2*localId];        if (2*globalId+1<length)  records[2*globalId+1] += temp[2*localId+1];    }}kernel void addBlock(global int* records,                     uint length,                     global int* blockSum,                     local int* temp){    int localId = get_local_id(0);    int globalId = get_global_id(0);    int groupId = get_group_id(0);        temp[2*localId] = 0;    temp[2*localId+1] = 0;    barrier(CLK_LOCAL_MEM_FENCE);        //memory copy    if (2*globalId<length)    temp[2*localId] = records[2*globalId];    if (2*globalId+1<length)  temp[2*localId+1] = records[2*globalId+1];    barrier(CLK_LOCAL_MEM_FENCE);        int thisBlockSum = 0;        if (groupId > 0) {        thisBlockSum = blockSum[groupId-1];        if (2*globalId < length)        temp[2*localId] += thisBlockSum;        if (2*globalId + 1 < length)    temp[2*localId + 1] += thisBlockSum;    }    barrier(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);        if (2*globalId < length)        records[2*globalId] = temp[2*localId];    if (2*globalId + 1 < length)    records[2*globalId + 1] = temp[2*localId+1];}