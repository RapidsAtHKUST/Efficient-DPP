#include "DataDef.h"//adjacent synchronizationinline void adjSyn(int blockId, int localId, global volatile int *inter, local int* r, local int *s){    if (localId == 0) {        int p = 0;        if (blockId == 0)   inter[0] = (*r);        else {            while ((p = inter[blockId-1]) == -1) {}            inter[blockId] = p + (*r);        }        *s = p;    }    barrier(CLK_LOCAL_MEM_FENCE);}//warp-wise intra-block scan (minimum depth), each thread only processes at most 1 elementvoid local_warp_scan(local int* lo, local int *sum) {    const unsigned localId = get_local_id(0);    const unsigned localSize = get_local_size(0);    const unsigned warpId = localId >> SCAN_BITS;           //warp ID    const unsigned warpNum = localSize >> SCAN_BITS;        //# warps    const unsigned lane = localId & SCAN_MASK;#define MAX_SUM_SIZE    (32)    local int sums[MAX_SUM_SIZE];       //local temporary sums    //1. Local warp-wise scan    int temp=lo[localId];    if (lane >= 1)      lo[localId] += lo[localId-1];    if (lane >= 2)      lo[localId] += lo[localId-2];    if (lane >= 4)      lo[localId] += lo[localId-4];    if (lane >= 8)      lo[localId] += lo[localId-8];    if (lane >= 16)     lo[localId] += lo[localId-16];    if (lane == SCAN_WARPSIZE-1)  sums[warpId] = lo[localId];   //get the warp sum    lo[localId] -= temp;                                        //exclusive minus    barrier(CLK_LOCAL_MEM_FENCE);    //2. Scan the intermediate sums    if (warpId == 0)  {        temp=sums[localId];        if (lane >= 1)      sums[localId] += sums[localId-1];        if (lane >= 2)      sums[localId] += sums[localId-2];        if (lane >= 4)      sums[localId] += sums[localId-4];        if (lane >= 8)      sums[localId] += sums[localId-8];        if (lane >= 16)     sums[localId] += sums[localId-16];        if (lane == SCAN_WARPSIZE-1)  *sum = sums[warpNum-1];   //get the total sum        sums[localId] -= temp;    }    barrier(CLK_LOCAL_MEM_FENCE);    //3. Add back    lo[localId] += sums[warpId];#undef MAX_SUM_SIZE}//intra-block fast matrix scaninline void local_scan_matrix(local int* lo, int ele_per_thread, local int* totalSum) {    const unsigned localId = get_local_id(0);    const unsigned localSize = get_local_size(0);    int tempStore;  //to store the first 1024 elements in the original lo array    int tempSum;    //1. Reduction (per thread)    int row_start = localId * ele_per_thread;    int row_end = (localId+1) * ele_per_thread;    int local_sum = 0;    for(int r = row_start; r < row_end; r++) {        local_sum += lo[r];    }    barrier(CLK_LOCAL_MEM_FENCE);    tempStore = lo[localId];                            //switch out the first localSize elements    lo[localId] = local_sum;    barrier(CLK_LOCAL_MEM_FENCE);    //2. Very fast scan on localSize elements    local_warp_scan(lo, totalSum);    tempSum = lo[localId];    lo[localId] = tempStore;                            //switch back the first localSize elements    barrier(CLK_LOCAL_MEM_FENCE);    //3. Scan    int local_temp0 = lo[row_start];    lo[row_start] = tempSum;    for(int r = row_start+1; r < row_end; r++) {        int local_temp1 = lo[r];        lo[r] = local_temp0 + lo[r-1];        local_temp0 = local_temp1;    }}kernel void scan_fast(        global int * d_in,                  //d_in: input array        const int length,                   //input length        local int * lo,                     //lo: local memory        const int lo_size,                  //#elements in the local memory        const int num_of_groups,            //#groups needed to be scanned        const int R,                        //elements per thread in the registers        const int L,                        //elements per thread in the local memory        global int * inter)                 //for adjacent sync{    const unsigned localId = get_local_id(0);    const unsigned localSize = get_local_size(0);    const unsigned groupId = get_group_id(0);    const unsigned groupSize = get_num_groups(0);    const unsigned warpId = localId >> SCAN_BITS;       //warp ID    const unsigned lane = localId & SCAN_MASK;          //lane ID in the warp    int c, l_begin_local, l_end_local, r_begin_local, r_end_local, reg[REGISTERS];    local int gs, gss;    int tempL;                  //how many elements a thread processes in the local memory    if (R!=0)   tempL = L+1;    else        tempL = L;    //static work-group execution    for(int w = groupId; w < num_of_groups; w += groupSize)    {        int l_begin_global = localSize * (R + L) * w;        int r_begin_global = l_begin_global + L * localSize;        //load to local memory and then to private registers        if (R != 0) {            r_begin_local = warpId * SCAN_WARPSIZE * R;            r_end_local = (warpId+1) * SCAN_WARPSIZE * R;            if (r_end_local + r_begin_global > length)   r_end_local = length - r_begin_global;            //load to local memory with coalesced access            c = r_begin_local + lane;            while (c < r_end_local) {                lo[c] = d_in[r_begin_global + c];                c += SCAN_WARPSIZE;            }            mem_fence(CLK_LOCAL_MEM_FENCE);            //from local memory to registers and scan at the same time            c = localId * R;            int localSum = 0;            for(int r = 0; r < R; r++) {                reg[r] = localSum;                localSum += lo[c+r];            }            barrier(CLK_LOCAL_MEM_FENCE);            lo[L*localSize + localId] = localSum;            barrier(CLK_LOCAL_MEM_FENCE);        }        //load to local memory        if (L != 0) {            l_begin_local = warpId * SCAN_WARPSIZE * L;            l_end_local = (warpId+1) * SCAN_WARPSIZE * L;            if (l_end_local + l_begin_global > length) l_end_local = length - l_begin_global;            c = l_begin_local + lane;            while (c < l_end_local) {                lo[c] = d_in[l_begin_global + c];                c += SCAN_WARPSIZE;            }            barrier(CLK_LOCAL_MEM_FENCE);        }        local_scan_matrix(lo, tempL, &gs);      //local memory scan     ,0.3ms        adjSyn(w, localId, inter, &gs, &gss);   //adjacent sync        //add back and copy the local mem to global memory        if (L != 0) {            c = l_begin_local + lane;            while (c < l_end_local) {                d_in[l_begin_global + c] = lo[c] + gss;                c += SCAN_WARPSIZE;            }        }        if (R != 0) {            int preSum = lo[L*localSize+localId] + gss;            barrier(CLK_LOCAL_MEM_FENCE);            //add back and copy the registers to local memory            c = localId * R;            for(int r = 0; r < R; r++)  lo[c+r] = reg[r] + preSum;            mem_fence(CLK_LOCAL_MEM_FENCE);            //from local memory to global memory, coalesced access            c = r_begin_local + lane;            while (c<r_end_local) {                d_in[r_begin_global + c] = lo[c];                c += SCAN_WARPSIZE;            }        }    }}//serial inefficient scaninline void local_scan_serial(local int* lo, int length, local int *sum) {    int localId = get_local_id(0);    if (localId == 0) {        int sum1 = lo[0];        lo[0] = 0;        for(int i = 1; i < length; i++) {            int cur = lo[i];            lo[i] = sum1;            sum1 += cur;        }        *sum =  sum1;    }    barrier(CLK_LOCAL_MEM_FENCE);}////intra-block fast matrix scan//inline void local_scan_matrix(local int* lo, int ele_per_thread, local int* totalSum) {////    const unsigned localId = get_local_id(0);//    const unsigned localSize = get_local_size(0);////#define MAX_THREAD_SIZE  (1024)//    local int sums[MAX_THREAD_SIZE];////    //1. Reduction (per thread)//    int row_start = localId * ele_per_thread;//    int row_end = (localId+1) * ele_per_thread;////    int local_sum = 0;//    for(int r = row_start; r < row_end; r++) {//        local_sum += lo[r];//    }//    sums[localId] = local_sum;//    barrier(CLK_LOCAL_MEM_FENCE);////    //2. Very fast scan on localSize elements//    local_warp_scan(sums, localSize, totalSum);               //0.2ms////    //3. Scan, 0.1ms//    int local_temp0 = lo[row_start];//    lo[row_start] = sums[localId];//    for(int r = row_start+1; r < row_end; r++) {//        int local_temp1 = lo[r];//        lo[r] = local_temp0 + lo[r-1];//        local_temp0 = local_temp1;//    }//#undef MAX_THREAD_SIZE//}